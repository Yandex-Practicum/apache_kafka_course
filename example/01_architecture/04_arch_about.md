# Описание архитектуры

У вас получилась уже достаточно серьёзная система. В ней есть модули для авторизации, администрирования и поиска контента. Эти системы работают с разными хранилищами и написаны на разных фреймворках. Дальнейшее развитие будет приводить к увеличению сложности всей системы онлайн-кинотеатра.

Этого не стоит бояться, такое развитие ждёт любой качественный и прибыльный проект. Со сложностью помогает справляться проектирование систем или архитектуры.

Если вы умеете проектировать архитектуру, вы понимаете, как должны развиваться системы и закладываться будущие риски. Такой навык спасёт вам многие часы. Разработчиков с архитектурными знаниями особенно ценят на рынке, так как они могут сэкономить деньги компании на будущих доработках.

Теперь пришла пора и вам познакомиться с тем, что делают архитекторы, и попробовать себя в этой роли!

## С чем и как работает архитектор

### Виды архитектур

Для начала стоит понять, какие есть виды архитектур, зачем они нужны в реальной практике, а также уместность применения того или иного вида.

Многим разработчикам обычно поручают рисовать **системную архитектуру**, или, как ещё её называют, **программную архитектуру**. В данном случае под термином «система» понимается конкретный сервис, который выполняет определённый набор функций. На практике можно встретить очень много определений такой архитектуры. Будут встречаться как архитектуры процессоров, так и архитектуры систем в разрезе разных компаний. Поэтому сосредоточимся на одном из определений: системная архитектура описывает архитектуру конкретного сервиса.

Когда системы были монолитными, разработчики проектировали внутреннее устройство кода системы вплоть до вызываемых функций и классов. На данный момент такая детализация обычно вредит, потому что каждое изменение кода потребует править архитектуру, что расточительно в эпоху гибких методологий. Поэтому обычно обрисовываются основные компоненты сервиса и его взаимодействие с внешними системами и БД.

Системная архитектура может выглядеть так:

![image](https://pictures.s3.yandex.net:443/resources/UGC_architecture_1_1630519384.png)

Или так:

![image](https://pictures.s3.yandex.net:443/resources/UGC_architecture_2_1630519389.png)

Следующий тип архитектуры — **архитектура решения** (англ. solution architecture). Этот вид архитектур уже более стандартизирован, но разночтения всё же встречаются. Суть такой архитектуры — показать, как разные системы должны интегрироваться друг с другом. У таких архитектур ограниченное применение, так как они не отражают подводных камней взаимодействия между компонентами. В основном это проекты, где требуется множество интеграций, например онлайн-кинотеатр.

Пример архитектуры решений:

![image](https://pictures.s3.yandex.net:443/resources/UGC_architecture_3_1630519393.png)

![image](https://pictures.s3.yandex.net:443/resources/UGC_architecture_3_1_1_1655313667.png)

Внешний вид подобного типа архитектуры может отличаться, но суть заключается в следующем: отражается только взаимодействие между сервисами с учётом используемых интерфейсов, без детализации того, что происходит внутри систем. 

И последний тип архитектур — **архитектура предприятия** (англ. enterprise architecture). Обычно такие архитектуры появляются в больших компаниях и в основном служат целям бизнеса. Одна из важных задач архитектуры предприятия — показать бизнесу, как с помощью IT [достичь выполнения стратегии компании или внести большие изменения в систему](https://mxsmirnov.com/2014/03/20/why-ea/){target="_blank"}. Поэтому важно понимать, что этот инструмент нужен в первую очередь, чтобы отобразить бизнес-функции на весь IT, а не на часть систем.

С помощью одной картинки не получится показать всю многогранность архитектуры предприятия. Зачастую графическое представление сильно зависит от стейкхолдеров, точки зрения (логическая, техническая и т. д.) и той проблемы, которую хочет решить бизнес. 

В рамках текущего курса вам предстоит рисовать архитектуру решения вашего онлайн-кинотеатра. Как показывает практика, именно такие архитектуры дают техническим командам понимание, что нужно сделать, но при этом не навязывают конкретный способ реализации функциональности. Ещё одно преимущество — при изменении внутренностей одного из сервисов такая архитектура не будет перерисовываться.

### Переход от требований к архитектуре

После того как вы определите функциональные и нефункциональные требования к вашей системе, вы можете начать процесс проектирования архитектуры. Но как точно осуществить этот переход? Вот основные шаги, которые помогут вам в этом:

1. **Определите основные компоненты системы**. Исходя из функциональных требований, определите основные компоненты или модули системы. Это могут быть различные службы, которые необходимы для выполнения ключевых функций, таких как обработка данных, управление пользовательскими сессиями или предоставление пользовательского интерфейса.
2. **Определите взаимодействия между компонентами**. Разработайте модель взаимодействия компонентов, исходя из функциональных требований. Какие компоненты должны взаимодействовать друг с другом? Какими данными они обмениваются? Какие протоколы или интерфейсы используются?
3. **Учтите нефункциональные требования**. Нефункциональные требования включают такие аспекты, как производительность, безопасность, надёжность и масштабируемость. Они влияют на выбор технологий, архитектурных шаблонов и даже на структуру вашей системы.
4. **Создайте диаграммы и документацию**. Ваша архитектура должна быть хорошо задокументирована. Создайте диаграммы взаимодействия, которые показывают, как ваши компоненты работают вместе. Опишите основные решения и принципы, которые лежат в основе вашей архитектуры.
5. **Проверка и итерация**. После того, как вы создали первоначальный проект архитектуры, проверьте его, убедитесь, что он удовлетворяет всем требованиям. Процесс проектирования архитектуры итеративен. Это означает, что он может потребовать несколько циклов проверки и изменений, прежде чем будет получен конечный результат. Не стесняйтесь возвращаться назад и изменять архитектуру по мере обнаружения новых требований или возникновения проблем. Основная цель — создать архитектуру, которая соответствует текущим и будущим потребностям вашей системы.

### Способы представления архитектуры

Среди архитекторов уже сложились определённые практики и инструменты для прототипирования архитектуры. Среди подходов к описанию архитектуры можно выделить несколько моделей: UML, матрица Захмана, 4+1 (С4), ArchiMate и TOGAF. Они зачастую пересекаются, что ещё раз подтверждает тезис о том, что архитектура программных систем — достаточно широкое понятие и для её описания нет единого способа и представления.

Архитекторы могут пользоваться широким спектром инструментов: начиная от Visio или draw.io и заканчивая специализированными инструментами вроде Visual Paradigm или Sparx Enterprise Architect. Последнее время начал набирать популярность PlantUML — способ описания архитектуры через текст. Это сокращает время на выравнивание графических элементов и позволяет сосредоточиться исключительно на содержательной части архитектуры.

Для текущего курса ограничимся простым, а главное, доступным инструментарием. В качестве модели описания будет использоваться UML-подобный формат, так как он достаточно часто применяется в различных организациях. Далее рассмотрим PlantUML — как наиболее «программистский» из подходов.

Основное преимущество PlantUML в том, что можно версионировать исходный код и отрисовывать картинку на лету в PyCharm или другом удобном редакторе.

Далее в уроке будет очень сжатое объяснение PlantUML, которое позволит вам нарисовать архитектуру для текущих задач. Все подробности — [в документации на русском языке](http://plantuml.com/ru/guide){target="_blank"}.

Рассмотрим конкретный пример применения PlantUML для описания части диаграммы про просмотр клиентом истории бонусов.

```
@startuml
skinparam componentStyle uml2
actor Клиент as Client
component WebApp
component LegacyWebBackend
database PostgresReplica
database LegacyElastic

Client -> WebApp: Просмотр истории бонусов
WebApp -> LegacyWebBackend: Просмотр истории бонусов
LegacyWebBackend -> PostgresReplica
LegacyWebBackend -down-> LegacyElastic
@enduml
```

Попробуйте вставить этот пример в выбранный вами редактор, чтобы увидеть результат. Должно получиться следующее:

![image](https://pictures.s3.yandex.net:443/resources/UGC_architecture_4_1630519401.png)

Теперь разберёмся с основными строительными блоками в PlantUML. По сути, всё сводится к двум моментам: участникам и связям между участниками.

Любой файл PlantUML должен содержать следующие директивы:

```
@startuml
...
@enduml
```

Далее описываются импорты сторонних компонентов, установка способа отображения, описание действующих компонентов и сама логика формирования диаграммы. Это прослеживается на примере выше:

1. `skinparam componentStyle uml2` устанавливает другой способ отрисовки компонентов. Попробуйте убрать его и увидеть, как изменится картинка.

2. Далее идёт описание действующих лиц. В базовом сценарии вначале описывается тип действующего лица, потом его название.

   ```
   <тип> <имя_для_отображения> [as <алиас_для_диаграммы>]
   ```

   ```
   actor Клиент as Client
   component WebApp
   component LegacyWebBackend
   database PostgresReplica
   database LegacyElastic
   ```

3. Описание взаимодействия. Идёт по следующему правилу:

   ```
   <Actor1> <тип взаимодействия> <Actor2>[: <описание>]
   ```

   ```
   Client -> WebApp: Просмотр истории бонусов
   WebApp -> LegacyWebBackend: Просмотр истории бонусов
   LegacyWebBackend -> PostgresReplica
   LegacyWebBackend -down-> LegacyElastic
   ```

Понимая эти базовые принципы, можно дальше нарисовать любую диаграмму. Например, [такую](https://medium.com/@yfuruyama/real-world-plantuml-7365ffc1b6e6){target="_blank"}:

![image](https://pictures.s3.yandex.net:443/resources/UGC_architecture_5_1630519406.png)

Второй часто используемый вид диаграмм для отображения — диаграммы последовательности (англ. sequence diagram). Они полезны для отображения логики работы, так как в них присутствуют условные операторы и циклы, которые сложно отобразить на компонентной диаграмме, о которой говорилось ранее.

Ниже представлен графический пример защищённой передачи сообщения из прошлого модуля:

![image](https://pictures.s3.yandex.net:443/resources/UGC_architecture_6_1630519420.png)
![image](https://pictures.s3.yandex.net:443/resources/UGC_architecture_6_1_1630519423.png)

```
@startuml
== Передача общего секрета ==
WebClient -> Service: Запрос аутентификации
activate WebClient
activate Service
Service --> WebClient: Аутентификация успешна
WebClient -> WebClient: Сгенерировать RSA-ключи
WebClient -> Service: Получить session_key (отдаём RSA pub)
Service -> Service: Сгенерировать session_key
Service -> Service: Зашифровать session_key
Service --> WebClient: Отдать зашифрованный session_key
deactivate Service
WebClient -> WebClient: Расшифровать session_key
alt Успешно расшифровано
	WebClient -> WebClient: Сохранить session_key
else Ошибка расшифровки
	WebClient -> WebClient: Не удалось расшифровать сообщение
end
deactivate WebClient

== Шифрование клиентских данных ==
WebClient -> Service: Получить персональные данные
activate WebClient
activate Service
Service -> Service: Получить персональные данные
Service -> Service: Зашифровать персональные данные (AES+session_key)
Service -> WebClient: Отдать зашифрованные данные
deactivate Service
WebClient -> WebClient: Расшифровать сообщение
alt Успешно расшифровано
	WebClient -> WebClient: Отобразить сообщение клиенту
else Ошибка расшифровки
	WebClient -> WebClient: Не удалось расшифровать сообщение
end
deactivate WebClient
@enduml
```

При помощи компонентной диаграммы не удастся описать такой процесс передачи данных — вы увидите только два компонента и стрелки между ними. Поэтому на практике компонентная диаграмма и диаграмма последовательности используются вместе.
