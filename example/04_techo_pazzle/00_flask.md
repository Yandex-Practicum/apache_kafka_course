# Что такое Flask

![image](https://github.com/Yandex-Practicum/python_p2f_ugc/blob/85b1251f022988f8715061825d9658584398641e/8th-sprint-refactor/04_techo_pazzle/images/middlepython_flask_illustration.jpeg)


[**Flask**](https://flask.palletsprojects.com/en/3.0.x/){target="_blank"} — это легковесный микрофреймворк для разработки веб-приложений на языке Python. Он предоставляет набор инструментов и расширений, с помощью которых можно быстро создавать простые и масштабируемые веб-приложения. На нём делают и лендинги, и многостраничные сайты с кучей плагинов и сервисов. 

Основные компоненты Flask: [Werkzeug](https://werkzeug.palletsprojects.com/en/3.0.x/){target="_blank"} — инструментарий для работы с WSGI, и [Jinja](https://jinja.palletsprojects.com/en/3.1.x/){target="_blank"} — шаблонизатор для генерации HTML.

### Основные преимущества Flask

- **Простота и легковесность**  
Flask — это микрофреймворк, то есть у него минимальное количество зависимостей, и он не навязывает определённой структуры проекта. Это позволяет разработчикам быстро начать работу над проектом и создавать индивидуальную архитектуру приложения.

- **Расширяемость**  
Flask имеет множество готовых расширений, которые позволяют добавлять новые функции в веб-приложение без необходимости создавать их с нуля.

- **Большое сообщество**  
Flask пользуется большой популярностью среди разработчиков, что обеспечивает активное развитие фреймворка и большое количество ресурсов для изучения и поддержки.

## Как работать с Flask

{{Flask — это веб-фреймворк.}}[p2f_last_stack] Он синхронный, так же как и [Django](https://www.djangoproject.com/){target="_blank"}, и минималистичный, как [FastApi](https://fastapi.tiangolo.com/){target="_blank"}.

В отличие от Django, у Flask «из коробки» ничего нет. В этом и есть его маленькая прелесть — его можно настраивать более гибко. В Django изначально включено очень многое, что усложняет конфигурирование приложения и делает обработку запроса более долгой. Поэтому, когда Django становится избыточным решением, используют Flask.

Установка Flask так же проста, как и у других фреймворков. Достаточно ввести команду `pip install Flask`.

Итак, для создания первого Flask-приложения, достаточно одного файла. Назовём его `app.py`.

```python
# flask_app/app.py
from flask import Flask


app = Flask(__name__)


@app.route('/hello-world')
def hello_world():
    return 'Hello, World!'


if __name__ == '__main__':
    app.run()
```

Для запуска приложения наберите `python app.py`. Получите примерно такой вывод:

```bash
 * Serving Flask app "app" (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
```

Когда вы запустили приложение, Flask предупредил, что запускать таким образом приложение в production-среде не стоит. И показал, на каком порту оно запущено. Этого вполне достаточно для проверки работоспособности приложения.

Откройте в браузере `http://127.0.0.1:5000/hello-world` — вы увидите `Hello, World!`.

## Библиотеки

Несмотря на то, что у Flask ничего нет в комплекте, для него есть множество готовых библиотек.

Другие разработчики уже составили списки «батареек» для Flask: 

- [список раз](https://github.com/humiaozuzu/awesome-flask){target="_blank"};
- [список два](https://github.com/mjhea0/awesome-flask){target="_blank"}.

Что вам может понадобиться для создания приложения:

- ORM для работы с PostgreSQL:
  * [SqlAlchemy](https://docs.sqlalchemy.org){target="_blank"} — самая популярная ORM для работы с реляционными БД на Python. Поддерживает SQLite, PostgreSQL, MySQL, Oracle и Microsoft SQL Server.
  * [Peewee](https://docs.peewee-orm.com){target="_blank"} — менее известная, но не менее прокачанная ORM для реляционных БД. Поддерживает SQLite, PostgreSQL и CockroachDB.
  * [Pony](https://docs.ponyorm.org){target="_blank"} — ещё одна ORM, но с более расширенной поддержкой. Поддерживает SQLite, PostgreSQL, MySQL, Oracle и CockroachDB.
- Библиотека для работы с Redis:  
  Самый простой вариант — найти её на сайте самого Redis. Открываем [список клиентов](https://redis.io/clients#python){target="_blank"} и выбираем, что больше всего понравится.
- Механизмы для создания RestAPI:
  * Валидация данных — [flask-marshmallow](https://github.com/marshmallow-code/flask-marshmallow){target="_blank"}.
  * Документация API — [flasgger](https://github.com/flasgger/flasgger){target="_blank"}.
  * А можно взять и аналоги [DRF](https://www.django-rest-framework.org/){target="_blank"}, но для Flask: [flask-restful](https://flask-restful.readthedocs.io){target="_blank"} или [flask-restplus](https://github.com/noirbizarre/flask-restplus){target="_blank"}. Практически всегда за удобство, краткость и универсальность приходится платить скоростью, поэтому будем использовать минимум помощников.
- Механизмы работы с сессиями (токены) — можно взять [flask-security](https://flask-security.readthedocs.io){target="_blank"}, потому что в ней уже есть необходимая функциональность.
- Чтобы не писать собственную реализацию генератора и валидатора JWT-токенов, вы можете воспользоваться [flask-jwt-extended](https://flask-jwt-extended.readthedocs.io/en/stable/){target="_blank"}.

Это только маленькая часть библиотек для Flask, решающих самые разные задачи. На примере видно, что без установки дополнительных библиотек сам Flask, в отличие от Django, умеет очень мало. Однако он очень лёгкий, простой, маленький и шустрый.

## Legacy

Разрабатывать новые сервисы всегда весело и интересно: проработка архитектуры, выбор технологий, написание кода, первый запуск в Production, первые пользователи и всё в этом духе. Но после запуска необходима ещё и поддержка сервиса: дальнейшее развитие, доработка новых фич, ремонт багов, оптимизация кода, поддержка legacy.

Представим, что вы устроились на работу в крупную компанию. Вам повезло, если вы попали в команду нового продукта, который только начал разрабатываться. Но чаще всего разработчики попадают в уже существующий продукт, у которого есть команда, а также написанные и запущенные в Production сервисы и свои клиенты.

И вот вы получили задачу увеличить быстродействие сервиса с минимальными трудовремязатратами. Сервис писался на старте продукта, документация по нему не велась, код был сделан на скорую руку, а программист, который его писал, уже уволился. Засада!

Ничего страшного, это стандартный сценарий :) Конечно, можно разобраться с кодом, составить документацию, описать API, написать тесты и переписать всё так, чтобы тесты не сломались. Но всего этого можно избежать.

Flask можно превратить в асинхронный фреймворк, не затрагивая исходный код. Вы помните, что асинхронность в Python — это не про скорость вычислений, а про количество одновременных корутин. Пока Flask синхронный, для масштабирования нужно увеличивать треды или процессы и добавлять новые реплики приложения. Но добавив асинхронность, вы полностью уберёте треды, снизите количество процессов, а главное — количество реплик приложения.

Другими словами, освободите ресурсы для других приложений. Меньше слов, больше дела!

## Legacy-приложение

```python
# flask_app/app.py
import requests
from flask import Flask


app = Flask(__name__)


@app.route('/hello-world')
def hello_world():
    requests.get('http://slow_application_host/slow-operation§')
    return 'Hello, World!'


if __name__ == '__main__':
    app.run()
```

Самый простой способ запустить приложение Flask — использовать встроенный сервер разработки. Но даже этот зверь поддерживает два режима обработки запросов:

1. В однопоточном режиме приложение Flask может обрабатывать не более одного HTTP-запроса за раз. То есть обработка запроса становится последовательной.

  `FLASK_APP=app flask run`  
   Команда `flask run` ищет точку входа в приложение в переменной окружения `FLASK_APP`.

2. В многопоточном режиме Flask порождает поток для каждого входящего HTTP-запроса. Однако максимальный параллелизм, то есть максимально возможное количество одновременных потоков, не настраивается.

  `FLASK_APP=app flask run --with-threads`

Чтобы сделать Flask асинхронным, используйте библиотеку [gevent](http://www.gevent.org/){target="_blank"}. Это сетевая Python-библиотека на основе сопрограмм, которая использует {{greenlet}}[p2f_greenlet] для обеспечения высокоуровневого синхронного API поверх цикла событий. До Python 3.5 библиотека gevent была основной для работы с корутинами. После этого корутины стали доступны в модуле asyncio, который стал частью стандартной библиотеки.

## Патч приложения

Итак, когда уже будет магия? Прямо сейчас!

Самый быстрый и простой способ раскрыть всю мощь gevent — использовать его встроенный WSGI-сервер под названием [gevent.pywsgi](http://www.gevent.org/api/gevent.pywsgi.html){target="_blank"}.

Установим библиотеку `pip install gevent` и добавим новую точку входа в приложение `pywsgi.py`.

```python
# flask_app/pywsgi.py
from gevent import monkey
monkey.patch_all()

from gevent.pywsgi import WSGIServer
from app import app


http_server = WSGIServer(('', 5000), app)
http_server.serve_forever()
```

Запустим приложение командой `python pywsgi.py`. Эта же инструкция есть и [в официальной документации Flask](https://flask.palletsprojects.com/en/3.0.x/deploying/gevent/){target="_blank"}.

Команда `monkey.patch_all()` и есть та самая магия! Именно она заменяет все I/O-операции на асинхронные. Важно её выполнить как можно раньше, ведь вы импортируете её первой и сразу же вызываете. Если внести правки слишком поздно, это может привести к непредсказуемуму поведению или ошибкам. Например, некоторые модули всё ещё могут использовать блокирующие сокеты.

Gevent можно использовать с gunicorn и uwsgi. Ведь куда без них в Production? Это даже проще, чем использовать `gevent.pywsgi.WSGIServer`.

Создадим файл `wsgi_app.py`.

```python
# flask_app/wsgi_app.py
from gevent import monkey
monkey.patch_all()

from app import app
```

Дальше для запуска указываем не `app.py`, а `wsgi_app.py`. 

В общем, gevent прост и эффективен! Но, конечно же, всегда будет несколько НО:

- Дебажить такой код будет практически нереально.
- Как бы красиво всё ни выглядело, патчиться будет далеко не всё.

В остальном этот способ оптимизации готового приложения на Flask достаточно простой и быстрый.
