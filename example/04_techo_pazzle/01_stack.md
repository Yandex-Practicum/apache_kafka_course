# Выбираем подходящий стек

Разработка подходящей архитектуры приложения — центральный элемент успешного проекта. Однако, независимо от того, насколько продумана и эффективна ваша архитектура, если технологический стек, на котором она основана, подобран неправильно, весь проект может столкнуться с серьёзными проблемами.

**Технологический стек** — это набор инструментов, технологий, языков программирования и фреймворков, которые используются для разработки и эксплуатации приложения. Стек включает в себя всё: от языка программирования до базы данных, брокера сообщений и фреймворка для тестирования. Отбор технологического стека имеет прямое влияние на нефункциональные характеристики вашего приложения: производительность, масштабируемость, безопасность и надёжность. Следовательно, этот выбор может стать ключевым фактором, определяющим успешность вашего проекта в целом. 

Правильный выбор технологического стека столь же важен, как и детально продуманная архитектура. В этом уроке мы рассмотрим ключевые аспекты выбора подходящего стека для вашего проекта.

## Выбор базы данных

Когда дело доходит до базы данных, два основных подхода, которые вы можете выбрать, это SQL и NoSQL (Not Only SQL). Они отличаются подходами к хранению и обработке данных, и каждый имеет свои уникальные преимущества. Выбор между ними в значительной степени зависит от требований вашего приложения и его архитектуры.

### SQL  

SQL-базы данных, такие как PostgreSQL, MySQL, SQLite и другие, используют структурированный язык запросов для взаимодействия с данными. Они имеют строгую схему, которая определяет структуру данных, что обеспечивает консистентность данных. SQL-базы данных подходят для ситуаций, где:

- Требуется строгая ACID-совместимость (Atomicity, Consistency, Isolation, Durability). Если ваше приложение предполагает сложные транзакции или обрабатывает критически важные данные, то SQL-база данных будет хорошим выбором.
- У данных сложные отношения между собой. Благодаря возможностям SQL для работы с отношениями, они идеально подходят для работы с данными, которые тесно взаимосвязаны.
- Вы работаете с монолитной архитектурой. SQL-базы данных хорошо интегрируются с традиционными монолитными приложениями.

Однако, не стоит забывать об ограничениях SQL-решений. Транзакции в SQL могут замедлить общую производительность приложения, особенно если они становятся большими или сложными. Кроме того, они могут вызвать блокировки и задержки в доступе к данным.  Также важно помнить, что SQL-базы данных традиционно разработаны для работы на одном сервере, что делает их сложными для горизонтального масштабирования или шардирования. Это может вызвать проблемы при обработке больших объёмов данных или выполнении транзакций и запросов через разные шарды.

### NoSQL

NoSQL-базы данных предлагают более гибкий подход к хранению данных. Это обширная категория, которая дополнительно разбивается на несколько подкатегорий, у каждой из которых есть своя собственная структура и свои преимущества.

- **Key-Value (Ключ-Значение)**. Эти базы данных (например, Redis и DynamoDB) хранят данные в парах ключ-значение. Главное преимущество — скорость. Они просты в использовании, потому что всё, что нужно знать для доступа к данным, — это ключ. Они идеально подходят для случаев, когда вам нужно быстро записывать и извлекать данные по ключу, что делает их отличным выбором для кэширования данных, хранения данных сеансов, реализации очередей сообщений и подобных задач. Однако, поскольку они предоставляют только базовые операции над данными (вставка, удаление, обновление и чтение по ключу), они могут быть не так полезны для более сложных запросов.  
- **Документоориентированные базы данных**. Эти базы данных (например, MongoDB и CouchDB) хранят данные в документах, обычно в формате JSON. Это позволяет хранить структурированные и полуструктурированные данные. Документоориентированные базы данных хорошо подходят для приложений, которые работают с большим количеством неструктурированных или полуструктурированных данных. Они также обеспечивают большую гибкость, так как позволяют изменять схему данных «на лету». Но если ваше приложение требует сложных запросов и транзакций, они могут быть не так эффективны, как реляционные базы данных.
- **Колоночные базы данных**. Эти базы данных (например, ClickHouse и Cassandra) хранят данные в колонках вместо строк. Это облегчает чтение и запись больших наборов данных, что делает их идеальными для обработки больших объёмов данных и аналитики. Колоночные базы данных отлично масштабируются, так как добавление новых колонок не замедляет их работу. Они отлично подходят для хранения и анализа большого количества однотипных данных, как, например, данные из IoT-устройств или лог-файлы. Однако, они могут быть избыточными для приложений, которым требуются сложные запросы или транзакции на уровне строки.

## Выбор брокера сообщений

При выборе брокера сообщений на рынке существует множество решений, включая платные, облачные и open-source варианты. В этом блоке мы рассмотрим два часто используемых open-source брокера, которые мы разбирали в рамках курса: Kafka и RabbitMQ.

**Модель хранения данных**. Kafka хранит все сообщения на диске и сохраняет их за определённый период времени, независимо от того, были они прочитаны или нет. Это позволяет повторно обрабатывать сообщения и обеспечивает очень высокую долговечность. В отличие от этого, RabbitMQ обычно удаляет сообщения после того, как они были доставлены и успешно обработаны, хотя у него есть возможность персистентного хранения сообщений.

**Модель доставки**. RabbitMQ использует push-модель доставки, при которой сообщения автоматически отправляются подписчикам, как только они поступают. Kafka использует pull-модель, при которой потребители активно запрашивают новые сообщения. Pull-модель может дать потребителям больше контроля над тем, когда и как они обрабатывают сообщения, но это также может привести к большей сложности и увеличению задержки при обработке сообщений.

**Производительность**. Kafka обычно предпочтительнее для сценариев с большим объёмом данных, поскольку она способна обрабатывать очень большие объёмы сообщений с высокой пропускной способностью. Однако стоит заметить, что за счёт модели pull, когда клиент сам забирает данные с сервера, время доставки конкретного сообщения может быть выше, чем в системах с push-моделью, таких как RabbitMQ. RabbitMQ также обеспечивает хорошую производительность и может быть быстрее в сценариях, где требуется минимальная задержка на доставку каждого отдельного сообщения, но может испытывать трудности при обработке очень больших потоков данных.

**Гибкость маршрутизации**. Одним из наиболее сильных аспектов RabbitMQ является его способность к гибкой и настраиваемой маршрутизации сообщений. RabbitMQ поддерживает несколько типов обменников, каждый из которых определяет свой уникальный алгоритм маршрутизации. В отличие от RabbitMQ, Kafka предоставляет более простую модель маршрутизации, основанную на концепции топиков. Топики в Kafka можно использовать для создания простой маршрутизации, они не обладают такой гибкостью и детализацией, как обменники в RabbitMQ. 


## Выбор веб-фреймворка

Сейчас у нас есть три кандидата, с которыми мы уже знакомы — Django, FastAPI и Flask. Все они являются популярными вариантами в мире Python, но предназначены для разных целей и имеют различные особенности.

**Django** — это довольно «взрослый» высокоуровневый веб-фреймворк, который следует принципу «батарейки включены». Это означает, что он предоставляет встроенные решения для большинства задач веб-разработки.

**FastAPI**, с другой стороны, — это современный, высокопроизводительный, асинхронный веб-фреймворк. Он идеально подходит для создания API, благодаря своей простоте, гибкости и производительности. 

**Flask** из них самый «древний», высокопроизводительный веб-фреймворк, позволяющий собирать необходимый функционал с помощью подключаемых плагинов.

При выборе между ними можно рассмотреть следующие факторы:

**Спектр предустановленных возможностей против гибкости настройки**

Django славится своим подходом batteries included: он предлагает широкий спектр предустановленных возможностей «из коробки». Это делает его отличным выбором для разработки сложных веб-приложений, требующих широкого набора функций. Кроме того, Django отлично подходит для быстрого развёртывания проектов, где время на реализацию важнее максимальной производительности, так как встроенные решения Django могут быть менее производительными по сравнению с тонко настроенными специализированными решениями.

FastAPI и Flask фокусированы на создании высокопроизводительных API и предлагают гибкость и лёгкость настройки. Они подходят для проектов, которые требуют индивидуальной настройки и позволяют разработчикам контролировать большую часть функциональности. FastAPI и Flask обеспечивают меньше функциональности «из коробки», но предоставляет разработчикам больше свободы в организации приложения, что может быть полезно в случае разработки специализированных приложений. 

**Синхронность против асинхронности** 

Django и Flask были разработаны как синхронные фреймворки, но со временем начали включать в себя некоторые асинхронные функции. Свежие версии [Django](https://docs.djangoproject.com/en/4.2/topics/async/#asynchronous-support){target="_blank"} и [Flask](https://flask.palletsprojects.com/en/2.3.x/async-await/){target="_blank"} поддерживают асинхронные вьюхи.

FastAPI же полностью асинхронный. Если ваша архитектура и рабочая нагрузка требуют большого количества асинхронных операций, FastAPI может быть более подходящим выбором. Но важно помнить, что из-за своей асинхронной природы, FastAPI может не подходить для проектов с CPU-интенсивной нагрузкой. Если же ваше приложение не требует значительной асинхронности, то Django с его богатыми функциональными возможностями или Flask с его гибкостью и легковесностью могут оказаться более удобным вариантом.

**Работа с базой данных**

Django оснащен встроенным ORM, который упрощает работу с реляционными базами данных. Это может быть особенно полезно, если ваш проект включает сложные запросы к базе данных или использует сложные отношения между объектами. Важно, однако, помнить, что Django ORM ориентирован на работу с реляционными базами. Если вы планируете использовать специализированную базу данных, например ClickHouse, этот аспект может стать ограничением, и значительная часть функционала ORM превращается в тыкву. 

В отличие от Django, FastAPI и Flask не имеют встроенного ORM. Но их гибкость позволяет взаимодействовать с любым Python ORM или даже написать собственное решение для взаимодействия с базой данных.

{quiz-task} background: | #82bbf2 content: | **Важно**: В этом спринте мы вам рекомендуем попробовать свои силы в использовании Flask при написании проекта. Этот опыт не будет лишним.{/quiz-task}


## Выбор фреймворка для тестирования

В мире Python существуют два основных игрока в области тестирования — это unittest и pytest. Каждый из них имеет свои сильные стороны и особенности, которые стоит учитывать при выборе.

**Unittest** входит в стандартную библиотеку Python и предоставляет обширный набор инструментов для тестирования вашего кода. Он поддерживает автоматическое обнаружение тестов, моки объектов, агрегацию тестов в группы и многое другое. Unittest использует подход, основанный на сценариях, с определением тестовых случаев через создание подклассов `unittest.TestCase`. Если вы уже знакомы с этим подходом (например, использовали JUnit в Java), то unittest может быть легче в освоении.

**Pytest** — более современный и гибкий инструмент для тестирования, с рядом преимуществ перед unittest. Во-первых, pytest предлагает более простой и лаконичный синтаксис, который делает написание тестов быстрее и проще. Во-вторых, он имеет мощную систему фикстур, которая делает управление тестовыми данными и состоянием более простым и гибким. Кроме того, pytest поддерживает как написание тестов в стиле unittest, так и более простой функциональный стиль, что делает его очень гибким в использовании.

Выбор между unittest и pytest в значительной степени зависит от ваших предпочтений. Если вам нужна простота и универсальность стандартной библиотеки Python, то unittest может быть подходящим выбором. Если же вы ищете более современные и продвинутые возможности для тестирования, то стоит рассмотреть pytest. 

Дополнительные факторы, которые помогут сделать выбор в пользу одного из фреймворков:

- **Кодовая база**. Если у вас уже большая кодовая база, написанная с использованием определённого фреймворка для тестирования, переход на другой фреймворк может потребовать значительных усилий. Например, если у вас уже много тестов, написанных с использованием unittest, переход на pytest может потребовать значительного рефакторинга кода.
- **Сложность тестового набора**. Если ваше приложение включает в себя сложные тесты с большим количеством параметров или требует сложных фикстур для подготовки окружения для тестов, pytest может быть более подходящим благодаря своим возможностям по параметризации тестов и мощным фикстурам.
- **Разработка в команде**. Если вы работаете в команде, учёт предпочтений и опыта коллег тоже важен. К примеру, если команда уже привыкла к определённому фреймворку, скажем, unittest, это может снизить затраты на обучение и ускорить разработку.

## Линтеры

В Python существуют различные линтеры, которые могут помочь вам улучшить свой код. Они бывают разных типов:

- **PEP8 линтеры**: это такие линтеры как Flake8, Pylint, PyCodeStyle и другие, которые проверяют ваш код на соответствие PEP8, официальному стильгайду Python. Эти линтеры помогают поддерживать код в чистоте и организованности, упрощая чтение и понимание кода. Они могут указывать на проблемы с форматированием, структурой кода и даже определёнными антипаттернами.
- **Линтеры для проверки типов**: такие как Mypy. Эти линтеры проверяют ваш код на соответствие аннотациям типов. Они могут быть полезны, особенно в больших проектах, где типы данных могут стать сложными и запутанными.
- **Продвинутые линтеры**: это такие линтеры как Bandit или Pyright, которые могут обнаруживать сложные ошибки, такие как уязвимости в безопасности или неэффективное использование ресурсов.

Все эти линтеры могут быть интегрированы в ваш процесс разработки, и обычно они используются совместно с системами контроля версий, чтобы автоматически проверять ваш код на предмет ошибок перед тем, как он будет объединён с основной веткой разработки.
