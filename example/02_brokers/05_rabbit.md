# Ушастая альтернатива

RabbitMQ — это одна из самых популярных open-source систем обмена сообщениями, которая поддерживает множество протоколов обмена сообщениями. Ключевая особенность RabbitMQ — гибкость в маршрутизации сообщений, использование push-модели для доставки сообщений и поддержка pub-sub (publish-subscribe) модели коммуникации прямо из коробки.

Как именно RabbitMQ будет адресовать сообщения, зависит от реализации протокола обмена сообщениями. RabbitMQ поддерживает несколько протоколов, хотя один из самых интересных — AMQP — Advanced Message Queuing Protocol.

Концептуальная модель AMQP простая и прямая. Она оперирует тремя сущностями: очередь (англ. queue), привязка (англ. binding) и точка обмена (англ. exchange).

Когда отправитель посылает сообщение в RabbitMQ, оно попадает в точку обмена. Затем точка обмена распределяет копии полученного сообщения между очередями, подключёнными к ней различными способами. И, наконец, сообщение доставляется до получателей, подписанных на очередь.

Сообщение — это просто набор любых данных. Оно состоит из полезной нагрузки (англ. payload — то, что отправило приложение) и метаданных, которые использует RabbitMQ для работы. 
Начиная с версии RabbitMQ 3.8.0, максимальный размер сообщения, который можно отправить в RabbitMQ, составляет 512 МБ. Это ограничение установлено для обеспечения стабильности и производительности системы.

Однако использование больших сообщений может вызывать проблемы. Помимо потенциальных проблем с производительностью и использованием памяти на сервере RabbitMQ, потребители и издатели также должны быть способны обрабатывать эти большие сообщения. Это может привести к проблемам, особенно в условиях ограниченных ресурсов или при работе с большим объёмом сообщений.

Поэтому, несмотря на то что RabbitMQ поддерживает большие сообщения, важно внимательно продумать свою стратегию обработки сообщений. Вместо передачи больших сообщений напрямую через RabbitMQ обычно рекомендуется использовать некоторую форму ссылки на данные. Например, вы можете сохранить большие данные в объектном хранилище или базе данных и отправить через RabbitMQ только ссылку на эти данные. Это позволяет сделать обработку сообщений более эффективной и масштабируемой.

Рассмотрим каждый компонент подробнее.

![image](https://pictures.s3.yandex.net:443/resources/notification_RabbitMQ_2_1630251994.png)


### Очередь

**Очередь** в RabbitMQ — это основное место хранения сообщений. Отправители посылают сообщения в распределители (англ. exchanges), которые затем маршрутизируют сообщения в одну или несколько очередей. Потребители затем подключаются к этим очередям для обработки и потребления сообщений. 

Ключевые особенности работы с очередями:

- **Длительность (Durability)**. Очереди в RabbitMQ могут быть либо долговременными (англ. durable), либо временными (англ. transient). Долговременная очередь выживет после перезагрузки брокера, тогда как временная очередь исчезнет, если брокер перезагрузится. Долговременные очереди используются для важных сообщений, которые нельзя потерять при сбое системы.

- **Эксклюзивность (Exclusivity)**. Очереди могут быть эксклюзивными — они привязаны к конкретному подключению. Когда подключение закрывается, очередь удаляется. Это полезно для временных очередей, которые специфичны для одного подключения.

- **Автоудаление (Auto-Delete)**. Очереди в RabbitMQ могут быть автоудаляемыми. Такая очередь будет удалена, как только от неё отключится последний потребитель.

- **TTL (Time to Live)**. В RabbitMQ можно установить TTL (время жизни) для сообщений в очереди: сообщения, которые находятся в очереди дольше установленного TTL, автоматически удаляются.

- **Dead Letter Exchange**. Это специальное место для сообщений, которые по каким-то причинам не получилось обработать. В RabbitMQ вы можете определить Dead Letter Exchange для очереди. Если сообщение отклонено, не может быть доставлено или превышает TTL, оно будет перенаправлено в указанный Dead Letter Exchange.


### Распределители

**Распределители** (англ. **Exchanges**) в RabbitMQ играют важную роль в том, как сообщения маршрутизируются от отправителей к очередям. Отправитель не отправляет сообщения напрямую в очередь; вместо этого продюсер отправляет сообщения в распределитель. Распределитель затем принимает это сообщение и маршрутизирует его в одну или несколько очередей на основе правил маршрутизации, которые вы определяете. 

Типы распределителей:

- **Direct Exchange**. Сообщение отправляется в очереди на основе ключа маршрутизации (англ. routing key). Так сообщение попадает в очередь, которая ожидает такой же ключ маршрутизации, как в сообщении.

- **Default Exchange**. Также известен как unnamed exchange. Он работает как Direct Exchange, но с одной особенностью — он автоматически маршрутизирует сообщения в очереди, основываясь на названии очереди. В этом случае ключ маршрутизации должен точно соответствовать имени очереди для успешной маршрутизации сообщений. Если ключ маршрутизации не совпадает с именем очереди, сообщение будет отброшено.

- **Fanout Exchange**. Сообщение отправляется во все связанные очереди без учёта маршрутного ключа. Если вы отправляете сообщение в fanout exchange, оно будет доставлено во все очереди, связанные с этим распределителем.

- **Topic Exchange**. Сообщения направляются в очереди на основе шаблона маршрутного ключа. Это означает, что могут быть очереди, связанные с распределителем, которые принимают сообщения на основе совпадения шаблона маршрутного ключа.

- **Headers Exchange**. Сообщения направляются в очереди на основе заголовков и их значений. Заголовки являются частью свойств сообщения и могут содержать произвольные пары ключ-значение.


### Привязки

В контексте RabbitMQ, привязки или Bindings, играют роль моста, связывающего распределители с очередями. Привязки определяют, как сообщения, отправленные в распределитель, будут маршрутизированы и доставлены в очереди. Без этих связей, распределители не знают, куда направлять сообщения, которые они получают.

Каждая связь включает в себя маршрутный ключ, который используется для определения, как сообщения маршрутизируются. Механизм маршрутизации зависит от типа распределителя. Например, в прямом распределителе (англ. Direct Exchange), маршрутный ключ должен точно совпадать с ключом маршрутизации сообщения, чтобы сообщение было доставлено в очередь.

Однако, нужно отметить, что привязки в RabbitMQ не создаются автоматически. Вы должны явно создать связь между распределителем и очередью и определить соответствующий маршрутный ключ.

Помимо основного ключа маршрутизации можно использовать аргументы для более гибкого контроля над связями. Это может быть полезно, например, если вы хотите управлять поведением сообщений с определёнными свойствами.

## Кластеризация

Кластеризация в RabbitMQ — это объединение нескольких брокеров вместе, чтобы они могли действовать как один логический брокер.

Кластер RabbitMQ состоит из одного или нескольких узлов, каждый из которых запускается на отдельной машине или в одном и том же хосте виртуальной машины. Все узлы в кластере RabbitMQ обмениваются метаданными, поэтому у них есть общее представление о состоянии кластера.

Некоторые преимущества кластеризации в RabbitMQ включают:

- **Масштабируемость**. Можно добавлять больше узлов в кластер для обработки увеличивающейся нагрузки.
- **Высокая доступность**. Если один узел выходит из строя, остальные узлы продолжают работать.
- **Прозрачность**. Клиенты могут подключаться к любому узлу в кластере, независимо от того, где находятся очереди или обмены.

## Федерация

Федерация в RabbitMQ позволяет объединять брокеры и кластеры вместе, что увеличивает размер и географическое распространение системы.

Федерация в RabbitMQ обычно используется для объединения нескольких отдельных кластеров в одну большую систему. Федерированные обмены и очереди могут передавать сообщения от одного кластера к другому, чтобы разделять нагрузку и обеспечивать географическую устойчивость.

Преимущества федерации в RabbitMQ включают:

- **Распределённая обработка**. Можно обрабатывать сообщения в разных географических регионах.
- **Толерантность к сбоям**. Если один кластер выходит из строя, другие кластеры продолжают работать.
- **Гибкость**. Федерация позволяет подключать и отключать кластеры по мере необходимости.


## О чём ещё не стоит забывать

- Все создаваемые очереди должны быть долговременными (англ. durable). То есть в настройках очереди должен стоять флаг `durable`. Это позволит не потерять данные при перезагрузке сервера.

- Сообщения должны отправляться с `delivery_mode=2` (то есть persistent). Этот параметр указывает серверу сохранять полученное сообщение на диск. Есть также `delivery_mode=1` (то есть non-persistent), который указывает, что сервер может выбрать, сохранять сообщение на диске или нет, в зависимости от его реализации и текущей загрузки. Это может быть быстрее, но ведёт к потере сообщения при остановке или сбое сервера.

- Если отправка сообщения не удалась, его лучше записать во временное хранилище, а через некоторое время попытаться отправить заново.

- В заголовках сообщений обязательно передавать параметр `X-Request-Id` — тот самый, который генерируется при любом входящем HTTP-запросе от пользователя и прокидывается во все зависимые запросы. Этот идентификатор запроса не только помогает отслеживать происхождение проблемы в логах, но и позволяет проводить трассировку запросов через разные службы и компоненты системы, включая очередь сообщений. Отслеживание запросов помогает создать полную картину взаимодействия компонентов в ходе обработки конкретного запроса, что очень полезно при диагностике проблем и оптимизации производительности.

- Не должно быть очередей, которые долго не разгребаются и бесконтрольно растут. Это может значительно повлиять на работоспособность сервера очередей, а значит, и на другие микросервисы. Очереди должны мониториться на возраст самого старого сообщения: нужно алертить, если этот возраст больше допустимого. Предпочтительный вариант решения: добавить больше консьюмеров или пересмотреть подход к решению задачи. RabbitMQ поставляется с [UI-интерфейсом управления и HTTP API](https://www.rabbitmq.com/monitoring.html){target="_blank"}, которые предоставляют [базовые метрики](https://www.rabbitmq.com/monitoring.html#rabbitmq-metrics){target="_blank"} по открытым соединениям, очередям, скорости циркулирования сообщений в системе.

## RabbitMQ и архитектура системы

Стоит отметить, что внедрение брокера сообщений может сделать систему более хрупкой. Дело в том, что теперь у разных компонентов системы появляется общая шина, данные в которой передаются по сети.

При принятии решения рассмотрите те же аргументы, как и при распиле монолита на микросервисы. Вы заменяете вызовы функций компонентов монолита на вызовы HTTP API методов. Они выполняются дольше — вероятность возникновения ошибки становится выше. Тем не менее, вы делаете этот выбор сознательно, обменивая риски на сильные стороны микросервисной архитектуры. Митигация рисков включает в себя внедрение защитных паттернов — Circuit Braker, деградацию API и других сценариев.

При взаимодействии через очереди сервисы должны быть идемпотентны, то есть устойчивы к повторной обработке одного и того же сообщения. Об этом нужно позаботиться разработчику, потому что подобная ситуация вполне допустима в протоколе сервера очередей.


### Квиз 

Какие из приведённых характеристик брокеров сообщений можно отнести к RabbitMQ?

- [x] Реализует взаимодействие по модели publisher-subscriber.
 > RabbitMQ поддерживает взаимодействие по модели publisher-subscriber, когда одно сообщение может быть доставлено нескольким подписчикам.
- [ ] Все сообщения записываются в журнал.
- [ ] Поддерживает как pull-based, так и push-based модель чтения сообщений.
- [x] Обладает гибкой машрутизацией.
 > Одно из ключевых преимуществ RabbitMQ — гибкость в маршрутизации сообщений. Это достигается за счёт использования обменников и связей с очередями. 


Выберите правильные утверждения относительно работы с распределителями в RabbitMQ:

- [ ] Direct Exchange направляет сообщения в очереди на основе заголовков и их значений.
- [x] Default Exchange автоматически маршрутизирует сообщения в очереди, основываясь на названии очереди.
   > Default (или unnamed) Exchange работает как Direct Exchange, но автоматически маршрутизирует сообщения в очереди на основании их названия.
- [ ] Fanout Exchange направляет сообщения в очереди только в том случае, если ключ маршрутизации точно соответствует имени очереди.
- [x] Topic Exchange направляет сообщения в очереди на основе шаблона маршрутного ключа.
   > Правильно. Topic Exchange позволяет маршрутизировать сообщения в очереди на основе совпадения шаблона маршрутного ключа.
- [x] Headers Exchange направляет сообщения в очереди на основе заголовков и их значений.
   > Правильно. Headers Exchange маршрутизирует сообщения в очереди исходя из заголовков сообщений и их значений.


Выберите верные утверждения о свойствах очередей в RabbitMQ:

- [x] Durable-очередь выживет после перезагрузки брокера.
   >  Durable-очереди в RabbitMQ сохраняются после перезагрузки брокера, обеспечивая надёжность важных сообщений.
- [ ] Эксклюзивная очередь может быть использована несколькими подключениями одновременно.
- [x] Автоудаляемая очередь будет удалена, как только от неё отключится последний потребитель.
   > Правильно. Если от очереди отключается последний потребитель, очередь, отмеченная как автоудаляемая, будет удалена.
- [ ] TTL в RabbitMQ определяет время жизни очереди, после которого она автоматически удаляется.
   
