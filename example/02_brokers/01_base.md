# Основы брокеров сообщений

В прошлом блоке мы погрузились в архитектуру программного обеспечения и узнали о важности тщательного анализа функциональных и нефункциональных требований. Они формируют ваш путь в создании сложных и надёжных систем.

Теперь, когда у вас есть чёткий образ того, что и как должна делать ваша система, появляется новый вопрос: «Как обеспечить эффективное взаимодействие между всеми компонентами системы?». Именно здесь на сцену выходят герои сегодняшнего урока — брокеры сообщений.

**Брокер сообщений** — это специализированная служба, облегчающая обмен данными между различными программными приложениями. Они принимают на себя задачу обработки, хранения и передачи данных от одного компонента системы к другому. В связи с этим, мы можем считать брокеры сообщений за своеобразных «переводчиков» или «посредников», способных обеспечивать надёжное и эффективное взаимодействие между компонентами, даже если эти компоненты разработаны с использованием разных технологий или работают в разных окружениях.

Брокеры сообщений играют важную роль в современной разработке программного обеспечения, особенно в контексте распределённых систем и микросервисной архитектуры, где отдельные компоненты могут работать независимо друг от друга, но при этом им требуется взаимодействовать и обмениваться данными для совместной работы. Брокеры сообщений обеспечивают эффективное, надёжное и безопасное взаимодействие между такими компонентами.

Данные, которые передаются через брокеры, обычно называются **сообщениями**. Сообщение может включать в себя любую информацию, которую требуется передать от одного компонента к другому — например, команды, уведомления, данные об ошибке и многое другое. Сообщения могут иметь различные форматы и структуры, в зависимости от требований конкретной системы и технологий, которые используются для разработки компонентов этой системы.

Представьте, что вы разрабатываете систему для крупного интернет-магазина. У вас есть сервис для обработки заказов, сервис для управления складом и сервис для уведомлений клиентов. Каждый из этих сервисов выполняет свои задачи и может работать независимо от других. Однако, для полноценной работы всей системы, эти сервисы должны взаимодействовать друг с другом.

Например, когда клиент совершает заказ, сервис обработки заказов должен уведомить сервис склада, чтобы он зарезервировал необходимые товары. Затем, когда товары готовы к отправке, сервис склада должен уведомить сервис обработки заказов, который, в свою очередь, должен уведомить сервис уведомлений, чтобы тот отправил клиенту сообщение о том, что его заказ готов.

В этом сценарии брокер сообщений выступает в роли «переводчика» или «посредника», который принимает сообщения от одного сервиса и пересылает их другому. Брокер сообщений может надёжно обработать эти сообщения, сохранить их до момента доставки, обеспечить их последовательность и в случае необходимости повторить попытку доставки, если первоначальная попытка оказалась неудачной.

С брокерами сообщений каждый сервис может сосредоточиться на своей основной задаче и не беспокоиться о деталях взаимодействия с другими сервисами.


![](https://github.com/Yandex-Practicum/python_p2f_ugc/blob/a5c0bee89df29f80a4aa62fea050f3790ac09664/8th-sprint-refactor/02_brokers/images/broker_architecture.png)


## Основные компоненты

Прежде чем начать полноценно использовать брокеры сообщений в системе, необходимо понять основные компоненты, которые входят в их структуру. Это поможет лучше разобраться, как различные части системы взаимодействуют между собой, и как можно использовать брокеры сообщений для повышения эффективности системы.

1. **Producer**, или Отправитель — это тот сервис или приложение, которое создаёт и отправляет сообщения. Отправитель может быть любым приложением, которое хочет отправить информацию другим сервисам. В нашем примере сервис обработки заказов и сервис склада могут выступать в роли Producer, отправляя сообщения о новых заказах и о готовности заказов к отправке соответственно.
2. **Consumer**, или Потребитель — это тот сервис или приложение, которое получает и обрабатывает сообщения. Потребитель подписывается на определённые очереди или темы в брокере сообщений и ждёт, когда туда будут помещены новые сообщения. 
3. **Subscription**, или Подписка — это механизм, с помощью которого Consumer может зарегистрировать свой интерес к определённым типам сообщений. Вместо того чтобы обрабатывать все сообщения в очереди, Consumer может выбрать только те, которые ему интересны. Это позволяет разделить обработку сообщений между различными Consumers, каждый из которых может специализироваться на определённых типах сообщений. В нашем примере сервис склада и сервис уведомлений могут выступать в роли Consumer, принимая сообщения о новых заказах и о готовности заказов к отправке соответственно.
3. **Message**, или Сообщение — это информация, которую отправляет Producer и которую получает Consumer. Оно может включать в себя различные данные, например, детали заказа или статус готовности заказа к отправке. Сообщение обычно содержит заголовок и тело. Заголовок может содержать метаданные, такие как идентификаторы сообщений или таймстампы, а тело содержит саму передаваемую информацию.
4. **Broker**, или Брокер сообщений является сердцем системы. Он принимает сообщения от Producer, и передаёт потребителям при их запросе. Брокер может поддерживать различные модели обмена сообщениями и обеспечивать различные гарантии доставки.

## Модели хранения сообщений

Мы рассмотрели основные компоненты системы обмена сообщениями и увидели, как сообщения передаются от отправителей к получателям через брокера. Однако мы ещё не касались вопроса о том, где и как эти сообщения хранятся в процессе их передачи. Ведь передача сообщений редко происходит мгновенно, и часто сообщения необходимо временно сохранить до того, как они будут обработаны.

В зависимости от конкретного брокера сообщений и его настроек, сообщения могут быть сохранены в различных структурах данных, каждая из которых имеет свои особенности. Существует несколько подходов к реализации хранения сообщений в брокерах: это могут быть очереди или журналы.

### Очередь

В самом простом случае очередь можно представить как линейный список сообщений, ожидающих обработки. Сообщения приходят в очередь от отправителей (Producer), где они остаются до тех пор, пока их не заберёт потребитель (Consumer) для обработки. После получения сообщения потребителем сообщение из очереди удаляется.

Очереди работают по принципу FIFO (First In, First Out), то есть первое пришедшее сообщение будет первым в очереди на обработку.

Основная идея очереди — это разделение процессов. Это означает, что отправители и потребители работают независимо друг от друга. Отправители могут отправлять сообщения в очередь, не думая о том, когда и как потребители будут их обрабатывать. С другой стороны, потребители могут забирать сообщения из очереди, когда они готовы к обработке, не беспокоясь о том, когда и какие сообщения будут приходить.

### Журнал

В отличие от очередей, где акцент делается на доставке сообщений от отправителей к потребителям, подход с использованием журнала сосредоточен на хранении и управлении записями данных или событий. В таком случае брокер сообщений действует как журнал событий или лог. Такой подход называется Log-based.

Сообщения, которые отправляются в брокер, сохраняются в последовательном и упорядоченном порядке, с каждым сообщением, добавляемым в конец лога. Как и в очереди, сообщения хранятся в порядке FIFO, но могут не удаляться после прочтения их потребителем. Иными словами — сообщения могут быть прочитаны многократно.

Ключевым аспектом подхода журнала является то, что потребители контролируют темп чтения сообщений из лога. Они поддерживают указатель на своё текущее положение в логе и могут передвигаться вперёд по своему собственному темпу. Это позволяет потребителям обрабатывать сообщения с разной скоростью и даже повторно обрабатывать старые сообщения при необходимости.

Журналы очень полезны в сценариях, где требуется обеспечить строгий порядок сообщений, устойчивость к сбоям и возможность обрабатывать данные с разной скоростью. Важно отметить, что журналы обычно требуют больше ресурсов по сравнению с очередями из-за хранения всех сообщений.


## Pull/Push-модели

В мире брокеров сообщений есть два основных подхода, определяющих, как сообщения передаются от брокера к потребителю: Pull-модель и Push-модель.

В **Pull**-модели Consumer активно запрашивает сообщения от брокера. Это немного похоже на то, как вы проверяете свою почту. Вы самостоятельно идёте к почтовому ящику (брокеру) и проверяете, есть ли там новые письма (сообщения).

Главным преимуществом этого подхода является то, что Consumer имеет полный контроль над тем, когда и как быстро он будет обрабатывать сообщения. Это может быть полезно, если у Consumer есть ограничения по ресурсам или если обработка сообщений занимает много времени. Также Pull-модель позволяет лучше адаптироваться к вариациям в объёме сообщений. Например, в случае, когда сообщения приходят пакетами, Consumer может опрашивать брокер чаще в пиковые периоды и реже в периоды затишья. Это позволяет избежать излишней нагрузки на систему и улучшает общую производительность.

Однако, это также означает, что Consumer должен постоянно опрашивать брокер на предмет новых сообщений, что может привести к неэффективному использованию ресурсов, если сообщения приходят нечасто.

В **Push**-модели брокер активно отправляет сообщения Consumer'ам, как только они становятся доступными. Это похоже на то, как вы получаете уведомления на свой смартфон. Вы не проверяете их самостоятельно — вместо этого они автоматически появляются на вашем экране, как только приходят.

Главным преимуществом этого подхода является его эффективность в отношении использования ресурсов, поскольку Consumer не тратит время и энергию на опрос брокера. Также такой подход может обеспечить более быструю обработку сообщений, поскольку они доставляются Consumer'у, как только становятся доступными.

Однако, это также может привести к проблемам, если Consumer не может обрабатывать сообщения так быстро, как они приходят. В этом случае сообщения могут накапливаться, и брокер может столкнуться с проблемами масштабирования или перегрузки.


## Стили взаимодействия с помощью сообщений

Существуют различные способы, которыми системы могут взаимодействовать друг с другом с использованием брокеров сообщений. Такие способы называются **паттернами использования** и они определяют, как сообщения передаются от отправителя к получателю. Понимание этих паттернов помогает определить, какой подход лучше всего подходит для решения конкретных задач в проекте. Разберём некоторые паттерны использования.

### One-Way  
Один из наиболее простых паттернов взаимодействия через брокер сообщений — это One-Way, или Однонаправленная связь. В этом случае отправитель (Producer) отправляет сообщение и не ожидает никакого ответа от потребителя (Consumer). То есть сообщение передаётся от одного компонента к другому в одну сторону без обратной связи.

**Пример использования One-Way:**
  
Допустим, у вас есть система логирования, которая собирает логи от разных сервисов в вашем приложении. В этом случае каждый из сервисов функционирует как отправитель, отправляя сообщения (логи) в брокер. Система логирования, в свою очередь, действует как потребитель, получая и обрабатывая логи. Здесь не требуется никакой обратной связи от системы логирования к сервисам — логи просто передаются и обрабатываются.

Однонаправленный паттерн обеспечивает быстрое и надёжное взаимодействие между компонентами и часто используется в системах, где важна скорость и отказоустойчивость, а обратная связь не требуется.

### Request-Reply 
В паттерне Request-Reply, или Запрос-Ответ, процесс обмена сообщениями становится немного сложнее, поскольку он включает в себя обратную связь от получателя к отправителю. В этом случае, система-отправитель (Producer) не просто отправляет сообщение и забывает о нём, как это происходит в паттерне One-Way. Она отправляет сообщение и ожидает ответа от получателя (Consumer). Чтобы реализовать стиль взаимодействия с асинхронными запросами/ответами, клиент и сервис обмениваются парными сообщениями. Клиент отправляет в очередь, принадлежащую сервису, сообщение с указанием операции и её параметров. Сервис обрабатывает запрос и возвращает в очередь, принадлежащую клиенту, ответное сообщение с результатом.

Проще говоря, в этом паттерне используется двусторонняя связь между отправителем и получателем. Это может быть полезно в тех случаях, когда отправителю требуется подтверждение того, что сообщение было обработано, или когда ему требуется дополнительная информация от получателя.

**Пример использования паттерна Request-Reply:**

Представьте, что вы работаете над системой бронирования авиабилетов. Клиент вводит информацию о желаемом маршруте и дате, а ваша система отправляет запрос в брокер сообщений. Ваш сервис «Поиск полётов» получает этот запрос, обрабатывает его, ищет подходящие рейсы, а затем отправляет ответное сообщение с результатами поиска обратно клиенту через брокер: классический пример использования паттерна Запрос-Ответ.

### Pub-Sub  
Pub-Sub, или Издатель-Подписчик, — это ещё один паттерн, который становится крайне полезным, когда одно сообщение должно быть получено и обработано несколькими получателями.

В этом паттерне система-отправитель, также называемая «издателем» (Publisher), отправляет сообщения, не заботясь о том, кто их получит. С другой стороны, получатели, или «подписчики» (Subscribers), подписываются на определённые типы сообщений, и брокер обеспечивает доставку этих сообщений всем подписчикам.

Это особенно полезно, когда сообщение имеет большое значение для многих частей вашей системы, и вы хотите, чтобы они все получили его и могли обработать независимо друг от друга.

**Пример использования паттерна Pub-Sub:**

Возьмём для примера оформление платной подписки в онлайн-кинотеатре. Генерируется событие «Покупка совершена», которое включает в себя информацию о покупке.

Это сообщение может быть отправлено в брокер сообщений, где оно будет доступно для всех заинтересованных подписчиков. Сервис авторизации может подписаться на это сообщение, чтобы знать, что пользователю нужно выдать роль платного подписчика. Сервис бухгалтерии может использовать эти данные для ведения финансовой отчётности. Сервис аналитики может обрабатывать эту информацию для создания отчётов о продажах.

Таким образом, одно сообщение обрабатывается несколькими сервисами, каждый из которых выполняет свою собственную, уникальную функцию в ответ на это сообщение.

## Гарантии доставки сообщений

Брокеры сообщений предоставляют разные уровни гарантии доставки для сообщений, которые проходят через них. Это важный аспект, который должны учитывать разработчики при выборе брокера сообщений и проектировании своих систем.

### At Most Once

При гарантии доставки At Most Once (от англ. «не более одного раза») каждое сообщение будет отправлено один раз. Если сообщение не было доставлено, оно не будет отправлено повторно. Такая гарантия используется в системах, где потеря некоторых сообщений приемлема. Например, если ваша система отслеживает клики на веб-сайте, потеря одного или двух кликов из миллионов может быть приемлемой.

### At Least Once

При гарантии доставки At Least Once (от англ. «минимум один раз») каждое сообщение будет доставлено по крайней мере один раз. Если сообщение не было доставлено, оно будет повторно отправлено до тех пор, пока получатель его не получит. Это может привести к ситуации, когда одно и то же сообщение обрабатывается несколько раз, поэтому вам придётся продумать механизм обработки возможных дубликатов сообщений.

### Exactly Once

При обработке сообщений Exactly Once (от англ. «ровно один раз») каждое сообщение будет обработано ровно один раз. Это наиболее сложный для реализации принцип, поскольку он требует сложной координации между отправителем и получателем, а также идемпотентности в обработке сообщений. Брокер не может контролировать работу сети и потребителя, поэтому невозможно гарантировать доставку Exactly Once. Однако, потребитель может реализовать механизм идемпотентности, который позволяет эффективно достигнуть обработки Exactly Once. Идемпотентность обработки сообщений означает, что повторная обработка одного и того же сообщения не приводит к изменению результатов. Другими словами, независимо от того, сколько раз мы применим операцию, результат будет один и тот же. Такой подход может быть крайне полезен в системах, где дубликаты или пропуски сообщений недопустимы. В общем виде обработка Exactly Once = доставка At Least Once + идемпотентность обработки.

Примером может быть система учёта зарплат, где каждый платёж должен быть выполнен точно один раз. Ни потеря платежа, ни его дублирование неприемлемы.

Использование каждого из этих подходов зависит от требований вашей системы. Некоторые брокеры сообщений поддерживают все эти гарантии доставки, позволяя вам выбрать наиболее подходящую для вашей ситуации.

## Обработка недоставленных сообщений (Dead Letter Queue)

В процессе обмена сообщениями между различными компонентами системы могут возникать ситуации, когда сообщение не может быть успешно доставлено или обработано. Это может быть вызвано ошибками на стороне получателя, проблемами с сетью, неправильным форматом сообщения и многим другим.

Для обработки таких ситуаций существуют специальные механизмы, одним из которых является Dead Letter Queue (DLQ, «очередь недоставленных сообщений»). DLQ — это концепция, используемая в системах обработки сообщений, которая представляет собой отдельную очередь для сообщений, не прошедших нормальную обработку. Вместо того чтобы просто отбросить такие сообщения, система может поместить их в DLQ для последующего анализа и обработки.

Основные аспекты применения DLQ:

- **Обработка ошибок**. DLQ используются для управления сообщениями, которые вызывают ошибки при обработке. Это может быть сообщение с неправильным форматом, которое вызывает исключение при попытке его обработать, или сообщение, которое не может быть доставлено из-за недоступности получателя.
- **Отложенная обработка**. Когда сообщение попадает в DLQ, оно остаётся там до тех пор, пока проблема не будет решена. Это может означать исправление кода, который обрабатывает сообщения, или восстановление работоспособности получателя. После этого сообщения могут быть перепосланы из DLQ для повторной обработки.
- **Мониторинг и оповещения**. DLQ можно использовать для мониторинга ошибок в вашей системе обработки сообщений. Например, увеличение количества сообщений в DLQ может указывать на проблему, которую нужно исследовать.
- **Предотвращение потери данных**. Без DLQ сообщения, которые вызывают ошибки, могут быть просто отброшены, что приводит к потере данных. DLQ позволяют сохранить эти сообщения для последующего анализа и возможной повторной обработки.

### Квиз

В какой модели чтения данных получатель может контролировать скорость обработки сообщений?

- [x] Pull-модель.
 >  В Pull-модели Consumer имеет полный контроль над тем, когда и как быстро он будет обрабатывать сообщения.
- [ ] Log-модель.
- [ ] Push-модель.
- [ ] Pub-sub-модель.

Укажите все верные удтверждение для Log-ориентированной системы:

- [ ] Log-ориентированные системы не подходят для аналитики в реальном времени.
- [x] Log-ориентированная система может обеспечивать отказоустойчивость и восстановление после сбоев.
 >  С помощью логов можно восстанавливать состояние системы после сбоев, поскольку логи сохраняют все изменения состояния системы.
- [ ] Log-ориентированные системы используют механизм удаления старых данных, чтобы сохранить только актуальную информацию.
- [x] Log-ориентированные системы используют журнал событий как основной источник данных.
 > Log-ориентированные системы действительно используют журнал событий (или лог) как основной источник данных. Все сообщения сохраняются в логе последовательно и упорядоченно.


Какая модель обмена сообщениями наиболее подходит для реализации сервиса пуш-уведомлений пользователям?

- [ ] Request-Reply.
- [ ] Pull-модель.
- [x] One-Way.
 > Сервис уведомлений просто получает сообщения из брокера и не ожидает от него обратной связи. Вместо этого он просто обрабатывает сообщения и отправляет уведомления пользователям в соответствии со своим темпом и потребностями.
- [ ] Pub-Sub.


В контексте систем обработки сообщений, для какой цели используется Dead Letter Queue (DLQ)?

- [ ] Для временного хранения всех входящих сообщений.
- [ ] Для хранения сообщений с высоким приоритетом.
- [x] Для хранения сообщений, которые не могли быть корректно обработаны.
 > Dead Letter Queue (DLQ) обычно используется в системах обработки сообщений для хранения сообщений, которые не могли быть корректно обработаны. Это могут быть сообщения, вызвавшие ошибку при обработке, сообщения, отклонённые приёмником, или сообщения, которые превысили предел количества попыток доставки. DLQ помогает при отладке проблем и предотвращает потерю сообщений, которые не были успешно обработаны.
- [ ] Для хранения сообщений с отложенной отправкой.


В рамках этого курса мы сосредоточим внимание на двух ключевых реализациях брокеров сообщений: Apache Kafka и RabbitMQ. Эти две системы были выбраны неслучайно. Они обладают различными фундаментальными концепциями и подходами к обработке сообщений, что делает их представителями двух разных классов брокеров сообщений.

RabbitMQ базируется на более классической модели брокера сообщений, ориентированной на доставку сообщений и обработку различных шаблонов обмена сообщениями.

Apache Kafka принципиально отличается от большинства традиционных брокеров сообщений, поскольку в основе его дизайна лежит концепция распределённого журнала событий, что обеспечивает высокую пропускную способность и возможность хранения больших объёмов данных.

Изучение обеих этих систем даст вам более широкое представление о возможностях и принципах работы брокеров сообщений и поможет принять более обоснованное решение при выборе подходящего инструмента для конкретных требований вашего приложения или инфраструктуры.


