## Как сохранять события в RabbitMQ

Важно понять, как именно вы будете сохранять события в RabbitMQ. Учитывая структуру распределителей, очередей и байндингов RabbitMQ, можно предложить три стратегии:

1. **Все события в один распределитель, у которого одна очередь**. Это наиболее простой подход, который легко реализовать и управлять. Все возможные события, независимо от пользователя или фильма, направляются в один распределитель, который затем направляет их в одну очередь.  
   - Из **преимуществ** можно явно выделить простоту — нет необходимости в сложной маршрутизации или управлении несколькими очередями.  
   - **Недостатком** является негибкость — все сообщения обрабатываются в одной очереди, без возможности отдельной обработки по типу события или сущности. Также непонятно, как это масштабировать — в случае большого объёма сообщений, все они попадают в одну очередь, что может привести к проблемам с производительностью и обработкой сообщений.

2. **Отдельный распределитель для каждого типа сущности, у каждого распределителя своя очередь**. Это подход среднего уровня сложности, который предлагает больше гибкости, чем первый вариант. Здесь создается отдельный распределитель для каждого типа сущности (например, пользователь и фильм), и каждый распределитель направляет сообщения в свою очередь.

3. **Отдельный распределитель для каждого типа сущности, у каждого распределителя есть очередь на каждый тип возможного события.** Это самый сложный подход, который предлагает наивысший уровень гибкости. В этом случае создается отдельный распределитель для каждого типа сущности (например, пользователь и фильм), и каждый распределитель направляет сообщения в отдельную очередь в зависимости от типа события. Сообщения можно обрабатывать отдельно для каждого типа события и сущности, что позволяет более точно контролировать обработку и маршрутизацию сообщений.
