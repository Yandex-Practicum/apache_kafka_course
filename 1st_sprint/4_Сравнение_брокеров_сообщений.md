В этом уроке будет приведено сравнение двух популярных брокеров сообщений - Apache Kafka и RabbitMQ.
Они различаются по принципам работы, подходам к доставке сообщений и поддержке персистентности. Это сделано для того,
чтобы вы смогли лучше понять на какие особенности инструмента нужно обращать внимание при работе с брокером.

### 1. **Модель передачи сообщений (Pull vs Push)**:

   **Kafka** использует _Pull-модель_. Это даёт им возможность работать с данными в своём собственном ритме, регулируя частоту запросов в зависимости 
   от нагрузки, что важно в распределённых системах, где важна способность масштабироваться.
  
 **RabbitMQ** использует _Push-модель_. Это удобно, когда сообщения нужно обрабатывать сразу, но может создавать трудности, 
 если потребители не успевают справляться с потоком сообщений, что приводит к их накоплению.

### 2. Персистентность:

**Kafka** хранит все сообщения в журнале (log), обеспечивая персистентность по умолчанию.
Благодаря персистентности, Kafka позволяет обращаться к сообщениям даже спустя значительное время, 
а старые данные удаляются только после завершения заданного периода хранения.

**RabbitMQ** тоже поддерживает персистентность, но её нужно настраивать вручную для каждого сообщения или очереди. 

### 3. Природа системы и использование:

   **Kafka** подходит для работы с большими данными, аналитики, систем мониторинга, где важно сохранять последовательность 
   сообщений и возможность их повторного чтения.
   
**RabbitMQ** поддерживает сложные паттерны маршрутизации сообщений и часто используется там, 
где важна быстрая доставка сообщений, но не требуется длительное хранение.

### 4. Гарантии доставки:

   **Kafka** предоставляет возможность конфигурировать гарантии доставки, такие как "как минимум один раз" или "только один раз". 
   Потребители сами контролируют процесс чтения, перемещаясь по логу в своём темпе.

   **RabbitMQ** поддерживает гарантии "как минимум один раз" и "возможно только один раз", 
   но за счёт Push-модели доставка зависит от способностей потребителей обрабатывать сообщения вовремя, что может повлиять на производительность и надёжность.

### 5. Производительность и масштабируемость:

   **Kafka** изначально спроектирована для работы с большими потоками данных и высокой нагрузкой, обеспечивая линейную масштабируемость.
   Она лучше подходит для систем, где необходимо обрабатывать миллионы сообщений в секунду.

   **RabbitMQ** работает хорошо для задач средней нагрузки, особенно когда нужны сложные маршрутизации и прямое взаимодействие между сервисами.
   При очень высокой нагрузке RabbitMQ может потребовать больше ресурсов и настройки.
  
###  Вывод:

   **Kafka** подходит для систем, где важна масштабируемая потоковая обработка и повторное чтение сообщений.
  
 **RabbitMQ** больше ориентирован на быструю доставку и асинхронную коммуникацию между сервисами.

## Квиз
**Вопрос 1:** 

Какую модель передачи сообщений использует Kafka?

A) Push-модель

B) Pull-модель

C) Hybrid-модель

D) FIFO-модель

Правильный ответ: B) Pull-модель

Пояснение: Kafka использует Pull-модель, позволяя потребителям запрашивать сообщения у брокера в своём ритме, 
что особенно важно для масштабируемых распределённых систем.

**Вопрос 2:** 

В чём основное различие в подходах к персистентности между Kafka и RabbitMQ?

A) В Kafka персистентность настраивается вручную для каждого сообщения

B) В RabbitMQ персистентность включена по умолчанию

C) В Kafka персистентность включена по умолчанию, а в RabbitMQ её нужно настраивать

D) В RabbitMQ сообщения хранятся неограниченно долго

Правильный ответ: C) В Kafka персистентность включена по умолчанию, а в RabbitMQ её нужно настраивать

Пояснение: Kafka хранит все сообщения в журнале с персистентностью по умолчанию, в то время как RabbitMQ требует 
ручной настройки персистентности для каждого сообщения или очереди.